{
  "kind": "implementation_plan",
  "version": "1.0",
  "title": "Keep the moving “No” button fully within the visible viewport",
  "requirements": [
    {
      "id": "REQ-1",
      "summary": "Constrain the Valentine Opening Screen “No” button so its rendered bounding box always stays fully inside the *visible* viewport (including mobile visualViewport offsets), and re-clamp safely on viewport changes without affecting other UI.",
      "acceptanceCriteria": [
        "When the user clicks the “No” button, its new position is always fully visible (no clipping on any edge) and fully clickable.",
        "Random positions are computed using safe bounds that subtract the button’s current rendered width and height from the available viewport area, with a consistent padding/margin.",
        "The computation correctly handles mobile/visual viewport scenarios (e.g., browser UI showing/hiding, zoom, orientation changes) so the button never appears partially outside the visible frame.",
        "On any viewport change events (resize/orientation/visualViewport resize/scroll), the current position is re-clamped so the button remains fully inside the visible viewport without jumping off-screen.",
        "No other UI behavior, text, styling, or screen flow is changed aside from the “No” button staying within bounds."
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/valentine/NoButton.tsx",
          "operation": "modify",
          "description": "Update the viewport-safe positioning logic to clamp against the *visible* viewport rectangle, not just width/height. Use window.visualViewport when available, including its offsetLeft/offsetTop (and current width/height) so fixed left/top are computed in layout-viewport coordinates that keep the button fully visible during mobile browser UI changes, zoom, and visualViewport scrolling. Ensure random position generation subtracts the button’s measured (getBoundingClientRect) width/height plus a consistent padding, then translate into final fixed coordinates (including visualViewport offsets). Add a robust re-clamp routine used on resize/orientationchange as well as visualViewport resize/scroll; optionally observe button size changes (e.g., ResizeObserver) to re-clamp if the button’s rendered size changes. Keep all other behavior and styling unchanged."
        }
      ]
    }
  ]
}